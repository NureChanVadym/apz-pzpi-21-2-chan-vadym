1 КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ
1.1	Мета роботи


Метою даної лабораторної роботи є розробка серверної частини для програмної системи управління автоматизованими вакцинаційними пунктами. Необхідно описати прийняті інженерні рішення, побудувати діаграми, представити архітектуру системи та структуру бази даних. 


1.2	Моделювання програмної системи


Для аналізу функціональності програмної системи управління автоматизованими вакцинаційними пунктами було розроблено декілька Use Case діаграм, які відображають різні ролі в системі. Першою для розгляду є Use Case діаграма для пацієнта (див. додаток А, рис. A.1). На цій діаграмі представлено одного активного актора – пацієнта, який має можливості для реєстрації, входу до особистого кабінету, перегляду вакцинаційних пунктів та їх графіків, перегляду історії записів, запису на вакцинацію, а також перегляду та редагування особистої інформації.
Для медичного персоналу створена Use Case діаграма (див. додаток А, рис. A.2), що демонструє можливості входу до особистого кабінету, перегляду пунктів вакцинувань та облікових записів пацієнтів, а також перегляду власної інформації. Розширені можливості включають перегляд кількості вакцин та їх оновлення, а також перегляд історії вакцинувань пацієнтів.
Use Case діаграма для адміністратора (див. додаток А, рис. A.3) включає вхід до особистого кабінету, керування вакцинаційними пунктами та обліковими записами медпрацівників та пацієнтів, перегляд облікових записів користувачів та пунктів вакцинувань. Розширення функціоналу адміністратора включає розподіл вакцин та перегляд їх кількості. Також в даній Use Case передбачені включення, такі як створення, редагування та видалення особистих кабінетів пацієнтів і медпрацівників. Це забезпечує гнучке управління системою та адаптивність до різних сценаріїв використання.
Кожна з цих Use Case діаграм представляє собою комплексний підхід до різних аспектів взаємодії учасників з системою, забезпечуючи глибоке розуміння потреб кожного актора та їх взаємодій з системою.
Для глибшого розуміння взаємодії між користувачами та системою InjectMeChan була розроблена діаграма взаємодії (див. додаток А, рис А.4), яка детально описує кроки взаємодії користувачів з системою при виборі та записі на вакцинацію. 
На даній діаграмі можна побачити послідовність дій користувача. Процес починається з запиту даних клієнтом, де користувач шукає доступні слоти для вакцинації, надсилаючи інформацію про вакцину, дату та вакцинаційний пункт. Сервер обробляє ці дані та повертає відповідні вільні слоти.
Далі, користувач вирішує, чи вибрати один із запропонованих термінів, а система перевіряє, чи має користувач права для здійснення запису. Якщо користувач має права, він просувається до створення запису, надсилаючи детальну інформацію про запис на вакцинацію на сервер. У випадку успішної перевірки усіх внутрішніх умов системою, користувач отримує успішний статус відповіді, інакше поверне код помилки. 


2 ПРОЕКТУВАННЯ БАЗИ ДАНИХ
2.1	Структура та взаємозв’язки у базі даних


Процес моделювання даних для програмної системи управління автоматизованими вакцинаційними пунктами передбачає визначення основних сутностей системи та встановлення логічних взаємозв'язків між ними. Можемо ідентифікувати такі ключові сутності: пацієнт, вакцинаційний пункт, інвентар вакцин, запис на вакцинацію, вакцина, графік роботи вакцинаційних пунктів, умови зберігання вакцин, та сповіщення IoT.
Сутність «Користувач» включає атрибути, такі як унікальний ID, пароль, телефон, електронна пошта, прізвище, ім'я, та роль, що дозволяє ідентифікувати та управляти правами доступу пацієнтів, медперсоналу та адміністраторів.
«Вакцинаційний пункт» містить деталі, такі як назва, адреса, телефон та електронна пошта, і служить центральною точкою для координації вакцинаційних подій та розкладу.
«Інвентар вакцин» є проміжною таблицею між сутностями «Вакцинаційний пункт» та «Вакцина». Вона має ключову роль у відстеженні доступності вакцин, зокрема кількості доз, що є критично важливим для забезпечення контролю та управління вакцинами в вакцинаційних пунктах.
Записи на вакцинацію представляють індивідуальні візити пацієнтів з атрибутами, як-от унікальний ID, дата та статус, дозволяючи слідкувати за розкладом та управляти потоком пацієнтів.
Сутність «Вакцина» включає назву, термін придатності, виробника та опис, надаючи повну інформацію про доступні вакцини для вакцинації.
«Графік роботи» узагальнює інформацію про час відкриття та закриття пунктів, а також дні тижня, коли проводиться вакцинація.
«Умови зберігання вакцин» та «Сповіщення IoT» є важливими для моніторингу стану вакцин та їх збереження, включаючи такі параметри, як тип умови (вологість, освітленість, температура), мінімальні та максимальні значення.
Для глибшого розуміння структури бази даних та зв'язків між сутностями, можна розглянути модель в додатку А на рисунку А.5. 
3 ПРОГРАМНА РЕАЛІЗАЦІЯ СЕРВЕРНОЇ ЧАСТИНИ
3.1	Розробка архітектури проекту


Архітектура програмної системи InjectMeChan була розроблена з урахуванням найкращих інженерних практик та сучасних вимог до високопродуктивних систем управління даними. Серверна частина базується на ASP.Net Core, яка відома своєю високою продуктивністю та легкістю впровадження. 
Взаємодія між сервером та клієнтами в системі відбувається через REST API, гарантуючи безпеку та ефективність доступу до її функціональності. REST методи, такі як GET для вибірки даних, POST для створення записів, PUT для оновлення існуючих даних, та DELETE для видалення, були ретельно сплановані для кожного аспекту системи, починаючи від реєстрації пацієнтів і до управління інвентаризацією вакцин. 
Архітектурні рішення, прийняті в процесі розробки системи InjectMeChan, були спрямовані на підтримку легкої масштабованості та розширення в майбутньому. З огляду на потребу в обробці великої кількості даних, було прийнято рішення про використання реляційної бази даних PostgreSql, яка добре зарекомендувала себе у великих і середніх проектах завдяки своїй надійності та продуктивності.
Програмний продукт використовує AutoMapper для зручної трансформації даних між різними моделями, що значно спрощує мапінг об'єктів і зменшує кількість коду. Для забезпечення безпеки криптографічних операцій використовується Cryptography.KeyDerivation. Ця бібліотека дозволяє безпечно зберігати паролі користувачів, використовуючи надійне хешування. Для взаємодії з базою даних використовується Entity Framework Core, який пропонує зручний та потужний механізм для роботи з базою даних PostgreSql через лінійні запити та зміни в схемі бази даних.
Для демонстрації та тестування API використовується Swagger UI, який інтегрований у ASP.Net Core проекти та дозволяє легко перевіряти та документувати всі REST методи. Всі запити та відповіді API передаються у форматі JSON, що забезпечує легкість обміну даними та їх інтеграцію з клієнтськими додатками. Серверна частина також підтримує HTTPS для захисту даних під час передачі, а автентифікація та авторизація користувачів забезпечуються через систему токенів, що додає додатковий рівень безпеки.
Принципи взаємодії серверної частини з іншими компонентами системи зображено на діаграмі розгортання (див. додаток А, рис. A.6). 


3.2	Програмна розробка системи


На основі ER-діаграми, яка відображає структуру бази даних і зв'язки між її елементами, були розроблені класи-моделі для системи InjectMeChan. Для прикладу, розглянемо клас Appointment (усі інші класи мають схожу структуру):

13     public class Appointment
14     {
15         public int Id { get; set; }
16         public int VaccinationPointId { get; set; }
17         public int UserId { get; set; }
18         public int VaccineId { get; set; }
19         public DateTime Date { get; set; }
20         public AppointmentStatus Status { get; set; }
21 
22         public VaccinationPoint VaccinationPoint { get; set; }
23         public User User { get; set; }
24         public Vaccine Vaccine { get; set; }
25     }

У цьому класі присутні поля, які безпосередньо відображають атрибути в базі даних (рядки 15-20), а також спеціальні поля для встановлення зв'язків з іншими об'єктами у базі даних (рядки 22-24), використовуючи Entity Framework Core. Така структура полягає у забезпеченні інтеграції моделей з базою даних, що дозволяє системі ефективно виконувати CRUD-операції.
Для взаємодії з базою даних був створений інтерфейс репозиторію, який визначав необхідні методи для роботи з даними. Далі була реалізована імплементація цього інтерфейсу, де кожен метод був конкретизований для виконання операцій з базою даних. Цей репозиторій не був використаний безпосередньо в контролерах, але замість цього застосовувався у сервісах для обробки бізнес-логіки. Такий підхід забезпечує розділення відповідальностей і сприяє чистоті коду.
Для ефективного обміну даними між різними рівнями програмної системи було використано підхід Data Transfer Object (DTO). Завдяки AutoMapper, що дозволяє легко трансформувати об'єкти одного типу в інший, створити DTO для безпечного обміну даними, що запобігає витоку конфіденційної інформації та забезпечує оптимізацію передачі лише необхідних даних.
Всі моделі, що представляють собою таблиці бази даних, були включені до класу ApplicationDataContext, що наслідується від класу DataContext. У цьому класі вони використовуються як поля для створення таблиць, встановлення зв'язків між ними, та ініціалізації початковими даними. Екземпляр ApplicationDataContext використовується в реалізаціях репозиторіїв кожної моделі, унаслідувавши від загального репозиторію. Такий підхід забезпечує централізоване управління даними та їхню інтеграцію з різними компонентами системи.
У системі InjectMeChan безпека користувацьких паролів забезпечена за рахунок використання хешування. Процес хешування паролів реалізовано у класі UserService (див. додаток Б.1 рядок 18). Коли користувач створюється, його пароль хешується методом HashPassword (див. додаток Б.1 рядки 76-80). У цьому методі спочатку генерується сіль (GenerateSalt), після чого використовується функція PBKDF2 (HashUsingPbkdf2) для створення хешу пароля з цією сіллю.
У рядку 47 (див. додаток Б.1) відбувається перевірка пароля, введеного користувачем, з використанням методу VerifyPassword (див. додаток Б.1 рядки 103-112). Цей метод спочатку витягує сіль і хеш з збереженого хешованого пароля користувача, а потім порівнює його з хешем введеного пароля, використовуючи ту ж саму сіль.
Такий підхід безпечно зберігати пароль та легко верифікувати його, оскільки хешування робить неможливим зворотнє відтворення оригінального пароля, а сіль захищає від атак з використанням готових таблиць хешів.
У процесі рефакторингу були застосовані такі методи рефакторингу: введення об'єкта параметра (Introduce Parameter Object) та виділення інтерфейсу (Extract Interface).
Рефакторинг «Введення Об'єкта Параметра» був застосований у класі AppointmentService для методу FindAvailableAppointmentsAsync (див. додаток Б.2 рядки 27). Раніше цей метод міг мати численні параметри, що ускладнювало його використання та розуміння. Введенням об'єкта параметра AppointmentSearchParams (див. додаток Б.3) спрощено передачу даних та підвищено читабельність методу.
У цьому випадку, AppointmentSearchParams агрегує всі необхідні параметри пошуку, такі як VaccineName, AppointmentDateFrom, AppointmentDateTo, та VaccinationPointName, у єдиний об'єкт, що значно спрощує виклик методу та його розширення у майбутньому.
Рефакторинг «Виділення Інтерфейсу» був застосований для класу WorkScheduleRepository. Цей метод дозволяє відділити декларацію методів від їх реалізації, сприяючи більшій гнучкості та тестуванню системи.
В даному випадку інтерфейс IWorkScheduleRepository декларує основні методи, такі як GetAllAsync, CreateAsync, UpdateAsync тощо (див. додаток Б.4 рядки 7-12), які потім реалізуються в класі WorkScheduleRepository (див. додаток Б.5 рядки 17-57). Це дозволяє легко замінити реалізацію репозиторію в майбутньому без необхідності зміни коду, що використовує цей інтерфейс. Також, це сприяє кращому розмежуванню відповідальностей та полегшує мокування (mocking) цих методів під час тестування.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1. Репозиторій проекту. URL: https://github.com/NureChanVadym/apz-pzpi-21-2-chan-vadym  
2. Посилання на відеозапис. URL: https://youtu.be/OnEwycwUs-o
